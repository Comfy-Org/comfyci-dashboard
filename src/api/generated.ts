/**
 * Generated by orval v6.28.2 üç∫
 * Do not edit manually.
 * Comfy API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import { customInstance } from './mutator/axios-instance';
export type ListAllNodeVersions200 = {
  /** Current page number */
  page?: number;
  /** Maximum number of node versions per page. Maximum is 100. */
  pageSize?: number;
  /** Total number of node versions available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
  versions?: NodeVersion[];
};

<<<<<<< HEAD
export type CreateWorkspaceSnapshot201 = {
  /** The unique identifier for the workspace snapshot */
  workspaceSnapshotId?: string;
};

export type CreateWorkspaceSnapshotBody = {
  /** A description of the workspace snapshot */
  description?: string;
};

export type GetWorkspaceSnapshots200 = {
  workspaceSnapshots?: WorkspaceSnapshot[];
};

export type UpdateWorkspace200 = {
  /** The unique identifier for the workspace */
  workspaceId?: string;
};

export type UpdateWorkspaceBody = {
  machine?: Machine;
  workflow?: Workflow;
};

export type GetWorkspace200 = {
  workspace?: Workspace;
};

export type CreateDefaultWorkspace201 = {
  /** The unique identifier for the default workspace */
  workspaceId?: string;
};

export type CreateWorkspace201 = {
  /** The unique identifier for the workspace */
  workspaceId?: string;
};

export type CreateWorkspaceBody = {
  /** The name of the workspace */
  name?: string;
};

export type GetWorkspaces200 = {
  workspaces?: Workspace[];
};

export type GetWorkspacesParams = {
limit?: number;
offset?: number;
};

export type CancelWorkflowJob200 = {
  /** A message confirming the cancellation request */
  message?: string;
};

export type UpdateWorkflowJobBody = {
  /** The updated list of output URLs generated by the workflow job */
  outputUrls?: string[];
  status?: WorkflowJobStatus;
};

export type CreateWorkflowJobBody = {
  /** The webhook will be called when the status of the job changes */
  webhookUrl: string;
};

export type GetWorkflow200AllOf = {
  authorId?: string;
  sessionId?: string;
};

export type GetWorkflow200 = Workflow & GetWorkflow200AllOf;

export type CreateWorkflowBody = {
  /** The JSON file content of the workflow. */
  fileContent: string;
  /** User-defined name for the workflow */
  name: string;
};

export type GetUserWorkflows200 = {
  workflows?: Workflow[];
};

export type GetUserWorkflowsParams = {
limit?: number;
offset?: number;
};

export type PostValidateTokenBody = {
  /** The access token to be validated. */
  token: string;
};

export type UpdateSessionBody = {
  /** The number of GPUs attached to this session. Can be 0 or 1. */
  gpuCount?: number;
  gpuType?: GPUType;
  /** Whether to update the end time of the session to 30 minutes from now. */
  updateEndTime?: boolean;
};

export type CreateSessionBody = {
  'gpu-type'?: GPUType;
};

export type GetSessions200 = {
  sessions?: Session[];
};

export type GetSessionsParams = {
=======
export type ListAllNodeVersionsParams = {
nodeId?: string;
statuses?: NodeVersionStatus[];
>>>>>>> 9eedfeb (Add url params.)
/**
 * The page number to retrieve.
 */
page?: number;
/**
 * The number of items to include per page.
 */
pageSize?: number;
};

export type PostUploadArtifact200 = {
  message?: string;
};

export type PostUploadArtifactBody = {
  /** The author of the commit */
  author: string;
  /** The average amount of VRAM used in the run. */
  avg_vram?: number;
  branch_name: string;
  /** The name of the bucket where the output files are stored */
  bucket_name?: string;
  /** The path to ComfyUI logs. eg. gs://bucket-name/logs */
  comfy_logs_gcs_path?: string;
  commit_hash: string;
  /** The commit message */
  commit_message: string;
  /** The time of the commit in the format of "YYYY-MM-DDTHH:MM:SSZ" (2016-10-10T00:00:00Z) */
  commit_time: string;
  /** Cuda version. */
  cuda_version?: string;
  /** The end time of the job as a Unix timestamp. */
  end_time: number;
  /** Unique identifier for the job */
  job_id: string;
  /** The user who triggered the job */
  job_trigger_user: string;
  machine_stats?: MachineStats;
  /** Operating system used in the run */
  os: string;
  /** A comma separated string that contains GCS path(s) to output files. eg. gs://bucket-name/output, gs://bucket-name/output2 */
  output_files_gcs_paths?: string;
  /** The peak amount of VRAM used in the run. */
  peak_vram?: number;
  /** The pull request number */
  pr_number: string;
  /** The python version used in the run */
  python_version: string;
  /** Repository name */
  repo: string;
  /** Unique identifier for the run */
  run_id: string;
  /** The start time of the job as a Unix timestamp. */
  start_time: number;
  status: WorkflowRunStatus;
  /** The name of the workflow */
  workflow_name: string;
};

<<<<<<< HEAD
=======
export type SecurityScanParams = {
minAge?: string;
maxNodes?: number;
};

>>>>>>> 9eedfeb (Add url params.)
export type CreatePersonalAccessToken201 = {
  /** The newly created personal access token. */
  token?: string;
};

<<<<<<< HEAD
=======
export type GetPermissionOnPublisher200 = {
  canEdit?: boolean;
};

>>>>>>> 9eedfeb (Add url params.)
export type PublishNodeVersion201 = {
  node_version?: NodeVersion;
  /** The signed URL to upload the node version token. */
  signedUrl?: string;
};

export type PublishNodeVersionBody = {
  node: Node;
  node_version: NodeVersion;
  personal_access_token: string;
};

<<<<<<< HEAD
=======
export type GetPermissionOnPublisherNodes200 = {
  canEdit?: boolean;
};

export type ListNodesForPublisherParams = {
/**
 * Number of nodes to return per page
 */
include_banned?: boolean;
};

>>>>>>> 9eedfeb (Add url params.)
export type ValidatePublisher200 = {
  /** True if the username is available, false otherwise. */
  isAvailable?: boolean;
};

export type ValidatePublisherParams = {
/**
 * The publisher username to validate.
 */
username: string;
};

<<<<<<< HEAD
=======
export type ListNodeVersionsParams = {
statuses?: NodeVersionStatus[];
};

export type PostNodeReviewParams = {
/**
 * number of star given to the node version
 */
star: number;
};

>>>>>>> 9eedfeb (Add url params.)
export type InstallNodeParams = {
/**
 * Specific version of the node to retrieve. If omitted, the latest version is returned.
 */
version?: string;
};

<<<<<<< HEAD
=======
export type SearchNodes200 = {
  /** Maximum number of nodes per page */
  limit?: number;
  nodes?: Node[];
  /** Current page number */
  page?: number;
  /** Total number of nodes available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
};

export type SearchNodesParams = {
/**
 * Page number of the nodes list
 */
page?: number;
/**
 * Number of nodes to return per page
 */
limit?: number;
/**
 * Keyword to search the nodes
 */
search?: string;
/**
 * Number of nodes to return per page
 */
include_banned?: boolean;
};

>>>>>>> 9eedfeb (Add url params.)
export type ListAllNodes200 = {
  /** Maximum number of nodes per page */
  limit?: number;
  nodes?: Node[];
  /** Current page number */
  page?: number;
  /** Total number of nodes available */
  total?: number;
  /** Total number of pages available */
  totalPages?: number;
};

export type ListAllNodesParams = {
/**
 * Page number of the nodes list
 */
page?: number;
/**
 * Number of nodes to return per page
 */
limit?: number;
<<<<<<< HEAD
=======
/**
 * Number of nodes to return per page
 */
include_banned?: boolean;
>>>>>>> 9eedfeb (Add url params.)
};

export type GetGitcommit200 = {
  jobResults?: ActionJobResult[];
  totalNumberOfPages?: number;
};

export type GetGitcommitParams = {
/**
 * The ID of the commit to fetch data for.
 */
commitId?: string;
/**
 * The operating system to filter the CI data by.
 */
operatingSystem?: string;
/**
 * The name of the workflow to filter the CI data by.
 */
workflowName?: string;
/**
 * The branch of the gitcommit to filter the CI data by.
 */
branch?: string;
/**
 * The page number to retrieve.
 */
page?: number;
/**
 * The number of items to include per page.
 */
pageSize?: number;
/**
 * The repo to filter by.
 */
repoName?: string;
};

export type GetBranch200 = {
  branches?: string[];
};

export type GetBranchParams = {
/**
 * The repo to filter by.
 */
repo_name?: string;
};

<<<<<<< HEAD
export interface WorkspaceSnapshot {
  /** A description of the workspace snapshot */
  description?: string;
  /** The unique id for this workflow snapshot. */
  id?: string;
}

/**
 * The status of the workflow being executed:
- `queued` - The job is in queue and will be executed soon.
- `started` - The job has started executing.
- `failed` - The job has failed.
- `succeeded` - The job has finished successfully.

 */
export type WorkflowJobStatus = typeof WorkflowJobStatus[keyof typeof WorkflowJobStatus];
=======
export type WorkflowRunStatus = typeof WorkflowRunStatus[keyof typeof WorkflowRunStatus];
>>>>>>> 9eedfeb (Add url params.)


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WorkflowRunStatus = {
  WorkflowRunStatusStarted: 'WorkflowRunStatusStarted',
  WorkflowRunStatusFailed: 'WorkflowRunStatusFailed',
  WorkflowRunStatusCompleted: 'WorkflowRunStatusCompleted',
} as const;

<<<<<<< HEAD
export interface WorkflowJob {
  id?: string;
  /** A list of URLs to the output generated by the workflow job. */
  outputUrls?: string[];
  status?: WorkflowJobStatus;
  /** This webhook will be called when the status of the job changes */
  webhookUrl?: string;
}

export interface Workflow {
  /** The unique id for this workflow. */
  id?: string;
  /** The date and time the workflow was last updated. */
  updatedAt?: string;
  /** The JSON representation of the workflow. */
  workflowJSON?: string;
  /** Name of the workflow */
  workflowName?: string;
}

export interface Workspace {
  /** The unique id for this workspace. */
  id?: string;
  machine?: Machine;
  /** The name of the workspace. */
  name?: string;
  workflow?: Workflow;
}

=======
>>>>>>> 9eedfeb (Add url params.)
export interface User {
  /** The email address for this user. */
  email?: string;
  /** The unique id for this user. */
  id?: string;
  /** Indicates if the user has admin privileges. */
  isAdmin?: boolean;
  /** Indicates if the user is approved. */
  isApproved?: boolean;
  /** The name for this user. */
  name?: string;
}

export interface StorageFile {
  /** Path to the file in storage */
  file_path?: string;
  /** Unique identifier for the storage file */
  id?: string;
  /** Public URL */
  public_url?: string;
}

<<<<<<< HEAD
/**
 * The status of the workflow being executed:
- `active` - The session is active and can be used.
- `inactive` - The session is inactive and cannot be used.

 */
export type SessionStatus = typeof SessionStatus[keyof typeof SessionStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SessionStatus = {
  active: 'active',
  inactive: 'inactive',
} as const;

export interface Session {
  /** [Output only] The number of GPUs attached to this session. */
  gpuCount?: number;
  gpuType?: GPUType;
  id?: string;
  machineType?: MachineType;
  /** This url to interface with this session. */
  publicUrl?: string;
  /** [Output only] The storage capacity of the session. */
  storage?: string;
}

=======
>>>>>>> 9eedfeb (Add url params.)
export interface PublisherUser {
  /** The email address for this user. */
  email?: string;
  /** The unique id for this user. */
  id?: string;
  /** The name for this user. */
  name?: string;
}

<<<<<<< HEAD
=======
export type PublisherStatus = typeof PublisherStatus[keyof typeof PublisherStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PublisherStatus = {
  PublisherStatusActive: 'PublisherStatusActive',
  PublisherStatusBanned: 'PublisherStatusBanned',
} as const;

export interface PublisherMember {
  /** The unique identifier for the publisher member. */
  id?: string;
  /** The role of the user in the publisher. */
  role?: string;
  user?: PublisherUser;
}

export interface Publisher {
  /** The date and time the publisher was created. */
  createdAt?: string;
  description?: string;
  /** The unique identifier for the publisher. It's akin to a username. Should be lowercase. */
  id?: string;
  /** URL to the publisher's logo. */
  logo?: string;
  /** A list of members in the publisher. */
  members?: PublisherMember[];
  name?: string;
  source_code_repo?: string;
  status?: PublisherStatus;
  support?: string;
  website?: string;
}

export interface PersonalAccessToken {
  /** [Output Only]The date and time the token was created. */
  createdAt?: string;
  /** Optional. A more detailed description of the token's intended use. */
  description?: string;
  /** Unique identifier for the GitCommit */
  id?: string;
  /** Required. The name of the token. Can be a simple description. */
  name?: string;
  /** [Output Only]. The personal access token. Only returned during creation. */
  token?: string;
}

export interface NodeVersionUpdateRequest {
  /** The changelog describing the version changes. */
  changelog?: string;
  /** Whether the version is deprecated. */
  deprecated?: boolean;
}

export type NodeVersionStatus = typeof NodeVersionStatus[keyof typeof NodeVersionStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NodeVersionStatus = {
  NodeVersionStatusActive: 'NodeVersionStatusActive',
  NodeVersionStatusDeleted: 'NodeVersionStatusDeleted',
  NodeVersionStatusBanned: 'NodeVersionStatusBanned',
  NodeVersionStatusPending: 'NodeVersionStatusPending',
  NodeVersionStatusFlagged: 'NodeVersionStatusFlagged',
} as const;

export type AdminUpdateNodeVersionBody = {
  status?: NodeVersionStatus;
  /** The reason for the status change. */
  status_reason?: string;
};

export interface NodeVersion {
  /** Summary of changes made in this version */
  changelog?: string;
  /** The date and time the version was created. */
  createdAt?: string;
  /** A list of pip dependencies required by the node. */
  dependencies?: string[];
  /** Indicates if this version is deprecated. */
  deprecated?: boolean;
  /** [Output Only] URL to download this version of the node */
  downloadUrl?: string;
  id?: string;
  status?: NodeVersionStatus;
  /** The reason for the status change. */
  status_reason?: string;
  /** The version identifier, following semantic versioning. Must be unique for the node. */
  version?: string;
}

export type NodeStatus = typeof NodeStatus[keyof typeof NodeStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NodeStatus = {
  NodeStatusActive: 'NodeStatusActive',
  NodeStatusDeleted: 'NodeStatusDeleted',
  NodeStatusBanned: 'NodeStatusBanned',
} as const;

export interface Node {
  author?: string;
  /** The category of the node. */
  category?: string;
  description?: string;
  /** The number of downloads of the node. */
  downloads?: number;
  /** URL to the node's icon. */
  icon?: string;
  /** The unique identifier of the node. */
  id?: string;
  latest_version?: NodeVersion;
  /** The path to the LICENSE file in the node's repository. */
  license?: string;
  /** The display name of the node. */
  name?: string;
  publisher?: Publisher;
  /** The average rating of the node. */
  rating?: number;
  /** URL to the node's repository. */
  repository?: string;
  status?: NodeStatus;
  /** The status detail of the node. */
  status_detail?: string;
  tags?: string[];
}

/**
 * Time series of VRAM usage.
 */
export type MachineStatsVramTimeSeries = { [key: string]: any };

export interface MachineStats {
  /** Total CPU on the machine. */
  cpu_capacity?: string;
  /** Total disk capacity on the machine. */
  disk_capacity?: string;
  /** Initial CPU available before the job starts. */
  initial_cpu?: string;
  /** Initial disk available before the job starts. */
  initial_disk?: string;
  /** Initial RAM available before the job starts. */
  initial_ram?: string;
  /** Total memory on the machine. */
  memory_capacity?: string;
  /** The operating system version. eg. Ubuntu Linux 20.04 */
  os_version?: string;
  /** The pip freeze output */
  pip_freeze?: string;
  /** Time series of VRAM usage. */
  vram_time_series?: MachineStatsVramTimeSeries;
}

>>>>>>> 9eedfeb (Add url params.)
export interface ErrorResponse {
  error: string;
  message: string;
}

export interface Error {
  /** Optional detailed information about the error or hints for resolving it. */
  details?: string[];
  /** A clear and concise description of the error. */
  message?: string;
}

export interface ActionJobResult {
  /** Identifier of the run this result belongs to */
  action_run_id?: string;
  /** The author of the commit */
  author?: string;
  /** The average VRAM used by the job */
  avg_vram?: number;
  /** The hash of the commit */
  commit_hash?: string;
  /** The ID of the commit */
  commit_id?: string;
  /** The message of the commit */
  commit_message?: string;
  /** The Unix timestamp when the commit was made */
  commit_time?: number;
  /** The end time of the job as a Unix timestamp. */
  end_time?: number;
  /** The repository name */
  git_repo?: string;
  /** GPU type used */
  gpu_type?: string;
  /** Unique identifier for the job result */
  id?: string;
  /** The user who triggered the job. */
  job_trigger_user?: string;
  machine_stats?: MachineStats;
  /** Operating system used */
  operating_system?: string;
  /** The peak VRAM used by the job */
  peak_vram?: number;
  /** The pull request number */
  pr_number?: string;
  /** PyTorch version used */
  python_version?: string;
  /** PyTorch version used */
  pytorch_version?: string;
  /** The start time of the job as a Unix timestamp. */
  start_time?: number;
  status?: WorkflowRunStatus;
  storage_file?: StorageFile;
  /** Name of the workflow */
  workflow_name?: string;
}




type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


/**
 * Only admins can approve a node version.
 * @summary Admin Update Node Version Status
 */
export const adminUpdateNodeVersion = (
    nodeId: string,
    versionNumber: string,
    adminUpdateNodeVersionBody: AdminUpdateNodeVersionBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<NodeVersion>(
      {url: `/admin/nodes/${nodeId}/versions/${versionNumber}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: adminUpdateNodeVersionBody
    },
      options);
    }
  


export const getAdminUpdateNodeVersionMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminUpdateNodeVersion>>, TError,{nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof adminUpdateNodeVersion>>, TError,{nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminUpdateNodeVersion>>, {nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody}> = (props) => {
          const {nodeId,versionNumber,data} = props ?? {};

          return  adminUpdateNodeVersion(nodeId,versionNumber,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type AdminUpdateNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof adminUpdateNodeVersion>>>
    export type AdminUpdateNodeVersionMutationBody = AdminUpdateNodeVersionBody
    export type AdminUpdateNodeVersionMutationError = ErrorResponse | void

    /**
 * @summary Admin Update Node Version Status
 */
export const useAdminUpdateNodeVersion = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminUpdateNodeVersion>>, TError,{nodeId: string;versionNumber: string;data: AdminUpdateNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getAdminUpdateNodeVersionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Returns all branches for a given repo.
 * @summary Retrieve all distinct branches for a given repo
 */
export const getBranch = (
    params: GetBranchParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetBranch200>(
      {url: `/branch`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetBranchQueryKey = (params: GetBranchParams,) => {
    return [`/branch`, ...(params ? [params]: [])] as const;
    }

    
export const getGetBranchQueryOptions = <TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(params: GetBranchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBranchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranch>>> = ({ signal }) => getBranch(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData> & { queryKey: QueryKey }
}

export type GetBranchQueryResult = NonNullable<Awaited<ReturnType<typeof getBranch>>>
export type GetBranchQueryError = void

/**
 * @summary Retrieve all distinct branches for a given repo
 */
export const useGetBranch = <TData = Awaited<ReturnType<typeof getBranch>>, TError = void>(
 params: GetBranchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBranch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetBranchQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns all runs, jobs, job results, and storage files associated with a given commit.
 * @summary Retrieve CI data for a given commit
 */
export const getGitcommit = (
    params?: GetGitcommitParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetGitcommit200>(
      {url: `/gitcommit`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetGitcommitQueryKey = (params?: GetGitcommitParams,) => {
    return [`/gitcommit`, ...(params ? [params]: [])] as const;
    }

    
export const getGetGitcommitQueryOptions = <TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(params?: GetGitcommitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGitcommitQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGitcommit>>> = ({ signal }) => getGitcommit(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGitcommitQueryResult = NonNullable<Awaited<ReturnType<typeof getGitcommit>>>
export type GetGitcommitQueryError = void

/**
 * @summary Retrieve CI data for a given commit
 */
export const useGetGitcommit = <TData = Awaited<ReturnType<typeof getGitcommit>>, TError = void>(
 params?: GetGitcommitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGitcommit>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGitcommitQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns a paginated list of nodes across all publishers.
 * @summary Retrieves a list of nodes
 */
export const listAllNodes = (
    params?: ListAllNodesParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ListAllNodes200>(
      {url: `/nodes`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListAllNodesQueryKey = (params?: ListAllNodesParams,) => {
    return [`/nodes`, ...(params ? [params]: [])] as const;
    }

    
<<<<<<< HEAD
export const getListAllNodesQueryOptions = <TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | Error>(params?: ListAllNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
=======
export const getListAllNodesQueryOptions = <TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | ErrorResponse>(params?: ListAllNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
>>>>>>> 9eedfeb (Add url params.)
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAllNodesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAllNodes>>> = ({ signal }) => listAllNodes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData> & { queryKey: QueryKey }
}

export type ListAllNodesQueryResult = NonNullable<Awaited<ReturnType<typeof listAllNodes>>>
<<<<<<< HEAD
export type ListAllNodesQueryError = void | Error
=======
export type ListAllNodesQueryError = void | ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

/**
 * @summary Retrieves a list of nodes
 */
<<<<<<< HEAD
export const useListAllNodes = <TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | Error>(
=======
export const useListAllNodes = <TData = Awaited<ReturnType<typeof listAllNodes>>, TError = void | ErrorResponse>(
>>>>>>> 9eedfeb (Add url params.)
 params?: ListAllNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListAllNodesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
<<<<<<< HEAD
=======
 * @summary Reindex all nodes for searching.
 */
export const reindexNodes = (
    
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/nodes/reindex`, method: 'POST'
    },
      options);
    }
  


export const getReindexNodesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reindexNodes>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof reindexNodes>>, TError,void, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reindexNodes>>, void> = () => {
          

          return  reindexNodes(requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type ReindexNodesMutationResult = NonNullable<Awaited<ReturnType<typeof reindexNodes>>>
    
    export type ReindexNodesMutationError = ErrorResponse

    /**
 * @summary Reindex all nodes for searching.
 */
export const useReindexNodes = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reindexNodes>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getReindexNodesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Returns a paginated list of nodes across all publishers.
 * @summary Retrieves a list of nodes
 */
export const searchNodes = (
    params?: SearchNodesParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SearchNodes200>(
      {url: `/nodes/search`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSearchNodesQueryKey = (params?: SearchNodesParams,) => {
    return [`/nodes/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchNodesQueryOptions = <TData = Awaited<ReturnType<typeof searchNodes>>, TError = void | ErrorResponse>(params?: SearchNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchNodesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchNodes>>> = ({ signal }) => searchNodes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchNodesQueryResult = NonNullable<Awaited<ReturnType<typeof searchNodes>>>
export type SearchNodesQueryError = void | ErrorResponse

/**
 * @summary Retrieves a list of nodes
 */
export const useSearchNodes = <TData = Awaited<ReturnType<typeof searchNodes>>, TError = void | ErrorResponse>(
 params?: SearchNodesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSearchNodesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
>>>>>>> 9eedfeb (Add url params.)
 * Returns the details of a specific node.
 * @summary Retrieve a specific node by ID
 */
export const getNode = (
    nodeId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Node>(
      {url: `/nodes/${nodeId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetNodeQueryKey = (nodeId: string,) => {
    return [`/nodes/${nodeId}`] as const;
    }

    
<<<<<<< HEAD
export const getGetNodeQueryOptions = <TData = Awaited<ReturnType<typeof getNode>>, TError = Error>(nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
=======
export const getGetNodeQueryOptions = <TData = Awaited<ReturnType<typeof getNode>>, TError = ErrorResponse>(nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
>>>>>>> 9eedfeb (Add url params.)
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodeQueryKey(nodeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNode>>> = ({ signal }) => getNode(nodeId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNodeQueryResult = NonNullable<Awaited<ReturnType<typeof getNode>>>
<<<<<<< HEAD
export type GetNodeQueryError = Error
=======
export type GetNodeQueryError = ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

/**
 * @summary Retrieve a specific node by ID
 */
<<<<<<< HEAD
export const useGetNode = <TData = Awaited<ReturnType<typeof getNode>>, TError = Error>(
=======
export const useGetNode = <TData = Awaited<ReturnType<typeof getNode>>, TError = ErrorResponse>(
>>>>>>> 9eedfeb (Add url params.)
 nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetNodeQueryOptions(nodeId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieves the node data for installation, either the latest or a specific version.
 * @summary Returns a node version to be installed.
 */
export const installNode = (
    nodeId: string,
    params?: InstallNodeParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NodeVersion>(
      {url: `/nodes/${nodeId}/install`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getInstallNodeQueryKey = (nodeId: string,
    params?: InstallNodeParams,) => {
    return [`/nodes/${nodeId}/install`, ...(params ? [params]: [])] as const;
    }

    
<<<<<<< HEAD
export const getInstallNodeQueryOptions = <TData = Awaited<ReturnType<typeof installNode>>, TError = Error | void>(nodeId: string,
=======
export const getInstallNodeQueryOptions = <TData = Awaited<ReturnType<typeof installNode>>, TError = ErrorResponse>(nodeId: string,
>>>>>>> 9eedfeb (Add url params.)
    params?: InstallNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInstallNodeQueryKey(nodeId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof installNode>>> = ({ signal }) => installNode(nodeId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData> & { queryKey: QueryKey }
}

export type InstallNodeQueryResult = NonNullable<Awaited<ReturnType<typeof installNode>>>
<<<<<<< HEAD
export type InstallNodeQueryError = Error | void
=======
export type InstallNodeQueryError = ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

/**
 * @summary Returns a node version to be installed.
 */
<<<<<<< HEAD
export const useInstallNode = <TData = Awaited<ReturnType<typeof installNode>>, TError = Error | void>(
=======
export const useInstallNode = <TData = Awaited<ReturnType<typeof installNode>>, TError = ErrorResponse>(
>>>>>>> 9eedfeb (Add url params.)
 nodeId: string,
    params?: InstallNodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof installNode>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getInstallNodeQueryOptions(nodeId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
<<<<<<< HEAD
 * @summary List all versions of a node
 */
export const listNodeVersions = (
    nodeId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NodeVersion[]>(
      {url: `/nodes/${nodeId}/versions`, method: 'GET', signal
=======
 * @summary Add review to a specific version of a node
 */
export const postNodeReview = (
    nodeId: string,
    params: PostNodeReviewParams,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Node>(
      {url: `/nodes/${nodeId}/reviews`, method: 'POST',
        params
>>>>>>> 9eedfeb (Add url params.)
    },
      options);
    }
  

<<<<<<< HEAD
export const getListNodeVersionsQueryKey = (nodeId: string,) => {
    return [`/nodes/${nodeId}/versions`] as const;
    }

    
export const getListNodeVersionsQueryOptions = <TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = Error>(nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
=======

export const getPostNodeReviewMutationOptions = <TError = void | Error | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postNodeReview>>, TError,{nodeId: string;params: PostNodeReviewParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postNodeReview>>, TError,{nodeId: string;params: PostNodeReviewParams}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postNodeReview>>, {nodeId: string;params: PostNodeReviewParams}> = (props) => {
          const {nodeId,params} = props ?? {};

          return  postNodeReview(nodeId,params,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type PostNodeReviewMutationResult = NonNullable<Awaited<ReturnType<typeof postNodeReview>>>
    
    export type PostNodeReviewMutationError = void | Error | ErrorResponse

    /**
 * @summary Add review to a specific version of a node
 */
export const usePostNodeReview = <TError = void | Error | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postNodeReview>>, TError,{nodeId: string;params: PostNodeReviewParams}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getPostNodeReviewMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary List all versions of a node
 */
export const listNodeVersions = (
    nodeId: string,
    params?: ListNodeVersionsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NodeVersion[]>(
      {url: `/nodes/${nodeId}/versions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListNodeVersionsQueryKey = (nodeId: string,
    params?: ListNodeVersionsParams,) => {
    return [`/nodes/${nodeId}/versions`, ...(params ? [params]: [])] as const;
    }

    
export const getListNodeVersionsQueryOptions = <TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = ErrorResponse | Error>(nodeId: string,
    params?: ListNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
>>>>>>> 9eedfeb (Add url params.)
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

<<<<<<< HEAD
  const queryKey =  queryOptions?.queryKey ?? getListNodeVersionsQueryKey(nodeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNodeVersions>>> = ({ signal }) => listNodeVersions(nodeId, requestOptions, signal);
=======
  const queryKey =  queryOptions?.queryKey ?? getListNodeVersionsQueryKey(nodeId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNodeVersions>>> = ({ signal }) => listNodeVersions(nodeId,params, requestOptions, signal);
>>>>>>> 9eedfeb (Add url params.)

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData> & { queryKey: QueryKey }
}

export type ListNodeVersionsQueryResult = NonNullable<Awaited<ReturnType<typeof listNodeVersions>>>
<<<<<<< HEAD
export type ListNodeVersionsQueryError = Error
=======
export type ListNodeVersionsQueryError = ErrorResponse | Error
>>>>>>> 9eedfeb (Add url params.)

/**
 * @summary List all versions of a node
 */
<<<<<<< HEAD
export const useListNodeVersions = <TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = Error>(
 nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListNodeVersionsQueryOptions(nodeId,options)
=======
export const useListNodeVersions = <TData = Awaited<ReturnType<typeof listNodeVersions>>, TError = ErrorResponse | Error>(
 nodeId: string,
    params?: ListNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListNodeVersionsQueryOptions(nodeId,params,options)
>>>>>>> 9eedfeb (Add url params.)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Retrieve a specific version of a node
 */
export const getNodeVersion = (
    nodeId: string,
    versionId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NodeVersion>(
      {url: `/nodes/${nodeId}/versions/${versionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetNodeVersionQueryKey = (nodeId: string,
    versionId: string,) => {
    return [`/nodes/${nodeId}/versions/${versionId}`] as const;
    }

    
<<<<<<< HEAD
export const getGetNodeVersionQueryOptions = <TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error>(nodeId: string,
=======
export const getGetNodeVersionQueryOptions = <TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error | ErrorResponse>(nodeId: string,
>>>>>>> 9eedfeb (Add url params.)
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodeVersionQueryKey(nodeId,versionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeVersion>>> = ({ signal }) => getNodeVersion(nodeId,versionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(nodeId && versionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNodeVersionQueryResult = NonNullable<Awaited<ReturnType<typeof getNodeVersion>>>
<<<<<<< HEAD
export type GetNodeVersionQueryError = Error
=======
export type GetNodeVersionQueryError = Error | ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

/**
 * @summary Retrieve a specific version of a node
 */
<<<<<<< HEAD
export const useGetNodeVersion = <TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error>(
=======
export const useGetNodeVersion = <TData = Awaited<ReturnType<typeof getNodeVersion>>, TError = Error | ErrorResponse>(
>>>>>>> 9eedfeb (Add url params.)
 nodeId: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNodeVersion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetNodeVersionQueryOptions(nodeId,versionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Retrieve all publishers
 */
export const listPublishers = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Publisher[]>(
      {url: `/publishers`, method: 'GET', signal
    },
      options);
    }
  

export const getListPublishersQueryKey = () => {
    return [`/publishers`] as const;
    }

    
<<<<<<< HEAD
export const getListPublishersQueryOptions = <TData = Awaited<ReturnType<typeof listPublishers>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
=======
export const getListPublishersQueryOptions = <TData = Awaited<ReturnType<typeof listPublishers>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
>>>>>>> 9eedfeb (Add url params.)
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPublishersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPublishers>>> = ({ signal }) => listPublishers(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData> & { queryKey: QueryKey }
}

export type ListPublishersQueryResult = NonNullable<Awaited<ReturnType<typeof listPublishers>>>
<<<<<<< HEAD
export type ListPublishersQueryError = void
=======
export type ListPublishersQueryError = ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

/**
 * @summary Retrieve all publishers
 */
<<<<<<< HEAD
export const useListPublishers = <TData = Awaited<ReturnType<typeof listPublishers>>, TError = void>(
=======
export const useListPublishers = <TData = Awaited<ReturnType<typeof listPublishers>>, TError = ErrorResponse>(
>>>>>>> 9eedfeb (Add url params.)
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListPublishersQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new publisher
 */
export const createPublisher = (
    publisher: Publisher,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Publisher>(
      {url: `/publishers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: publisher
    },
      options);
    }
  


<<<<<<< HEAD
export const getCreatePublisherMutationOptions = <TError = void | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};
=======
export const getCreatePublisherMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};
>>>>>>> 9eedfeb (Add url params.)

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPublisher>>, {data: Publisher}> = (props) => {
          const {data} = props ?? {};

          return  createPublisher(data,requestOptions)
        }

        


<<<<<<< HEAD
  return  { mutationFn, ...mutationOptions }}

    export type CreatePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof createPublisher>>>
    export type CreatePublisherMutationBody = Publisher
    export type CreatePublisherMutationError = void | Error
=======
   return  { mutationFn, ...mutationOptions }}

    export type CreatePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof createPublisher>>>
    export type CreatePublisherMutationBody = Publisher
    export type CreatePublisherMutationError = ErrorResponse | void
>>>>>>> 9eedfeb (Add url params.)

    /**
 * @summary Create a new publisher
 */
<<<<<<< HEAD
export const useCreatePublisher = <TError = void | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createPublisher>>,
        TError,
        {data: Publisher},
        TContext
      > => {
=======
export const useCreatePublisher = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPublisher>>, TError,{data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
>>>>>>> 9eedfeb (Add url params.)

      const mutationOptions = getCreatePublisherMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Checks if the publisher username is already taken.
 * @summary Validate if a publisher username is available
 */
export const validatePublisher = (
    params: ValidatePublisherParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ValidatePublisher200>(
      {url: `/publishers/validate`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getValidatePublisherQueryKey = (params: ValidatePublisherParams,) => {
    return [`/publishers/validate`, ...(params ? [params]: [])] as const;
    }

    
<<<<<<< HEAD
export const getValidatePublisherQueryOptions = <TData = Awaited<ReturnType<typeof validatePublisher>>, TError = Error | void>(params: ValidatePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
=======
export const getValidatePublisherQueryOptions = <TData = Awaited<ReturnType<typeof validatePublisher>>, TError = ErrorResponse>(params: ValidatePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
>>>>>>> 9eedfeb (Add url params.)
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidatePublisherQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validatePublisher>>> = ({ signal }) => validatePublisher(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData> & { queryKey: QueryKey }
}

export type ValidatePublisherQueryResult = NonNullable<Awaited<ReturnType<typeof validatePublisher>>>
<<<<<<< HEAD
export type ValidatePublisherQueryError = Error | void
=======
export type ValidatePublisherQueryError = ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

/**
 * @summary Validate if a publisher username is available
 */
<<<<<<< HEAD
export const useValidatePublisher = <TData = Awaited<ReturnType<typeof validatePublisher>>, TError = Error | void>(
=======
export const useValidatePublisher = <TData = Awaited<ReturnType<typeof validatePublisher>>, TError = ErrorResponse>(
>>>>>>> 9eedfeb (Add url params.)
 params: ValidatePublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validatePublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getValidatePublisherQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete a publisher
 */
export const deletePublisher = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}`, method: 'DELETE'
    },
      options);
    }
  


<<<<<<< HEAD
export const getDeletePublisherMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};
=======
export const getDeletePublisherMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};
>>>>>>> 9eedfeb (Add url params.)

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePublisher>>, {publisherId: string}> = (props) => {
          const {publisherId} = props ?? {};

          return  deletePublisher(publisherId,requestOptions)
        }

        


<<<<<<< HEAD
  return  { mutationFn, ...mutationOptions }}

    export type DeletePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof deletePublisher>>>
    
    export type DeletePublisherMutationError = Error
=======
   return  { mutationFn, ...mutationOptions }}

    export type DeletePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof deletePublisher>>>
    
    export type DeletePublisherMutationError = ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

    /**
 * @summary Delete a publisher
 */
<<<<<<< HEAD
export const useDeletePublisher = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deletePublisher>>,
        TError,
        {publisherId: string},
        TContext
      > => {
=======
export const useDeletePublisher = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
>>>>>>> 9eedfeb (Add url params.)

      const mutationOptions = getDeletePublisherMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Retrieve a publisher by ID
 */
export const getPublisher = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Publisher>(
      {url: `/publishers/${publisherId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPublisherQueryKey = (publisherId: string,) => {
    return [`/publishers/${publisherId}`] as const;
    }

    
<<<<<<< HEAD
export const getGetPublisherQueryOptions = <TData = Awaited<ReturnType<typeof getPublisher>>, TError = void>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
=======
export const getGetPublisherQueryOptions = <TData = Awaited<ReturnType<typeof getPublisher>>, TError = ErrorResponse>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
>>>>>>> 9eedfeb (Add url params.)
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublisherQueryKey(publisherId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublisher>>> = ({ signal }) => getPublisher(publisherId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPublisherQueryResult = NonNullable<Awaited<ReturnType<typeof getPublisher>>>
<<<<<<< HEAD
export type GetPublisherQueryError = void
=======
export type GetPublisherQueryError = ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

/**
 * @summary Retrieve a publisher by ID
 */
<<<<<<< HEAD
export const useGetPublisher = <TData = Awaited<ReturnType<typeof getPublisher>>, TError = void>(
=======
export const useGetPublisher = <TData = Awaited<ReturnType<typeof getPublisher>>, TError = ErrorResponse>(
>>>>>>> 9eedfeb (Add url params.)
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPublisherQueryOptions(publisherId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update a publisher
 */
export const updatePublisher = (
    publisherId: string,
    publisher: Publisher,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Publisher>(
      {url: `/publishers/${publisherId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: publisher
    },
      options);
    }
  


<<<<<<< HEAD
export const getUpdatePublisherMutationOptions = <TError = Error | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};
=======
export const getUpdatePublisherMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};
>>>>>>> 9eedfeb (Add url params.)

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePublisher>>, {publisherId: string;data: Publisher}> = (props) => {
          const {publisherId,data} = props ?? {};

          return  updatePublisher(publisherId,data,requestOptions)
        }

        


<<<<<<< HEAD
  return  { mutationFn, ...mutationOptions }}

    export type UpdatePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof updatePublisher>>>
    export type UpdatePublisherMutationBody = Publisher
    export type UpdatePublisherMutationError = Error | void
=======
   return  { mutationFn, ...mutationOptions }}

    export type UpdatePublisherMutationResult = NonNullable<Awaited<ReturnType<typeof updatePublisher>>>
    export type UpdatePublisherMutationBody = Publisher
    export type UpdatePublisherMutationError = ErrorResponse | void
>>>>>>> 9eedfeb (Add url params.)

    /**
 * @summary Update a publisher
 */
<<<<<<< HEAD
export const useUpdatePublisher = <TError = Error | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updatePublisher>>,
        TError,
        {publisherId: string;data: Publisher},
        TContext
      > => {
=======
export const useUpdatePublisher = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePublisher>>, TError,{publisherId: string;data: Publisher}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
>>>>>>> 9eedfeb (Add url params.)

      const mutationOptions = getUpdatePublisherMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
<<<<<<< HEAD
=======
 * @summary Ban a publisher
 */
export const banPublisher = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}/ban`, method: 'POST'
    },
      options);
    }
  


export const getBanPublisherMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof banPublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof banPublisher>>, TError,{publisherId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof banPublisher>>, {publisherId: string}> = (props) => {
          const {publisherId} = props ?? {};

          return  banPublisher(publisherId,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type BanPublisherMutationResult = NonNullable<Awaited<ReturnType<typeof banPublisher>>>
    
    export type BanPublisherMutationError = ErrorResponse

    /**
 * @summary Ban a publisher
 */
export const useBanPublisher = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof banPublisher>>, TError,{publisherId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getBanPublisherMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
>>>>>>> 9eedfeb (Add url params.)
 * @summary Retrieve all nodes
 */
export const listNodesForPublisher = (
    publisherId: string,
<<<<<<< HEAD
=======
    params?: ListNodesForPublisherParams,
>>>>>>> 9eedfeb (Add url params.)
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Node[]>(
<<<<<<< HEAD
      {url: `/publishers/${publisherId}/nodes`, method: 'GET', signal
=======
      {url: `/publishers/${publisherId}/nodes`, method: 'GET',
        params, signal
>>>>>>> 9eedfeb (Add url params.)
    },
      options);
    }
  

<<<<<<< HEAD
export const getListNodesForPublisherQueryKey = (publisherId: string,) => {
    return [`/publishers/${publisherId}/nodes`] as const;
    }

    
export const getListNodesForPublisherQueryOptions = <TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = void>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
=======
export const getListNodesForPublisherQueryKey = (publisherId: string,
    params?: ListNodesForPublisherParams,) => {
    return [`/publishers/${publisherId}/nodes`, ...(params ? [params]: [])] as const;
    }

    
export const getListNodesForPublisherQueryOptions = <TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = ErrorResponse>(publisherId: string,
    params?: ListNodesForPublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
>>>>>>> 9eedfeb (Add url params.)
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

<<<<<<< HEAD
  const queryKey =  queryOptions?.queryKey ?? getListNodesForPublisherQueryKey(publisherId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNodesForPublisher>>> = ({ signal }) => listNodesForPublisher(publisherId, requestOptions, signal);
=======
  const queryKey =  queryOptions?.queryKey ?? getListNodesForPublisherQueryKey(publisherId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNodesForPublisher>>> = ({ signal }) => listNodesForPublisher(publisherId,params, requestOptions, signal);
>>>>>>> 9eedfeb (Add url params.)

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData> & { queryKey: QueryKey }
}

export type ListNodesForPublisherQueryResult = NonNullable<Awaited<ReturnType<typeof listNodesForPublisher>>>
<<<<<<< HEAD
export type ListNodesForPublisherQueryError = void
=======
export type ListNodesForPublisherQueryError = ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

/**
 * @summary Retrieve all nodes
 */
<<<<<<< HEAD
export const useListNodesForPublisher = <TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = void>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListNodesForPublisherQueryOptions(publisherId,options)
=======
export const useListNodesForPublisher = <TData = Awaited<ReturnType<typeof listNodesForPublisher>>, TError = ErrorResponse>(
 publisherId: string,
    params?: ListNodesForPublisherParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNodesForPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListNodesForPublisherQueryOptions(publisherId,params,options)
>>>>>>> 9eedfeb (Add url params.)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new custom node
 */
export const createNode = (
    publisherId: string,
    node: Node,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Node>(
      {url: `/publishers/${publisherId}/nodes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: node
    },
      options);
    }
  


<<<<<<< HEAD
export const getCreateNodeMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};
=======
export const getCreateNodeMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};
>>>>>>> 9eedfeb (Add url params.)

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNode>>, {publisherId: string;data: Node}> = (props) => {
          const {publisherId,data} = props ?? {};

          return  createNode(publisherId,data,requestOptions)
        }

        


<<<<<<< HEAD
  return  { mutationFn, ...mutationOptions }}

    export type CreateNodeMutationResult = NonNullable<Awaited<ReturnType<typeof createNode>>>
    export type CreateNodeMutationBody = Node
    export type CreateNodeMutationError = Error
=======
   return  { mutationFn, ...mutationOptions }}

    export type CreateNodeMutationResult = NonNullable<Awaited<ReturnType<typeof createNode>>>
    export type CreateNodeMutationBody = Node
    export type CreateNodeMutationError = ErrorResponse | void
>>>>>>> 9eedfeb (Add url params.)

    /**
 * @summary Create a new custom node
 */
<<<<<<< HEAD
export const useCreateNode = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createNode>>,
        TError,
        {publisherId: string;data: Node},
        TContext
      > => {
=======
export const useCreateNode = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNode>>, TError,{publisherId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
>>>>>>> 9eedfeb (Add url params.)

      const mutationOptions = getCreateNodeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a specific node
 */
export const deleteNode = (
    publisherId: string,
    nodeId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}`, method: 'DELETE'
    },
      options);
    }
  


<<<<<<< HEAD
export const getDeleteNodeMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};
=======
export const getDeleteNodeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};
>>>>>>> 9eedfeb (Add url params.)

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNode>>, {publisherId: string;nodeId: string}> = (props) => {
          const {publisherId,nodeId} = props ?? {};

          return  deleteNode(publisherId,nodeId,requestOptions)
        }

        


<<<<<<< HEAD
  return  { mutationFn, ...mutationOptions }}

    export type DeleteNodeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNode>>>
    
    export type DeleteNodeMutationError = Error
=======
   return  { mutationFn, ...mutationOptions }}

    export type DeleteNodeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNode>>>
    
    export type DeleteNodeMutationError = ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

    /**
 * @summary Delete a specific node
 */
<<<<<<< HEAD
export const useDeleteNode = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteNode>>,
        TError,
        {publisherId: string;nodeId: string},
        TContext
      > => {
=======
export const useDeleteNode = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
>>>>>>> 9eedfeb (Add url params.)

      const mutationOptions = getDeleteNodeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Update a specific node
 */
export const updateNode = (
    publisherId: string,
    nodeId: string,
    node: Node,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Node>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: node
    },
      options);
    }
  


<<<<<<< HEAD
export const getUpdateNodeMutationOptions = <TError = Error | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};
=======
export const getUpdateNodeMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};
>>>>>>> 9eedfeb (Add url params.)

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateNode>>, {publisherId: string;nodeId: string;data: Node}> = (props) => {
          const {publisherId,nodeId,data} = props ?? {};

          return  updateNode(publisherId,nodeId,data,requestOptions)
        }

        


<<<<<<< HEAD
  return  { mutationFn, ...mutationOptions }}

    export type UpdateNodeMutationResult = NonNullable<Awaited<ReturnType<typeof updateNode>>>
    export type UpdateNodeMutationBody = Node
    export type UpdateNodeMutationError = Error | void
=======
   return  { mutationFn, ...mutationOptions }}

    export type UpdateNodeMutationResult = NonNullable<Awaited<ReturnType<typeof updateNode>>>
    export type UpdateNodeMutationBody = Node
    export type UpdateNodeMutationError = ErrorResponse | void
>>>>>>> 9eedfeb (Add url params.)

    /**
 * @summary Update a specific node
 */
<<<<<<< HEAD
export const useUpdateNode = <TError = Error | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateNode>>,
        TError,
        {publisherId: string;nodeId: string;data: Node},
        TContext
      > => {
=======
export const useUpdateNode = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNode>>, TError,{publisherId: string;nodeId: string;data: Node}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
>>>>>>> 9eedfeb (Add url params.)

      const mutationOptions = getUpdateNodeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
<<<<<<< HEAD
=======
 * @summary Ban a publisher's Node
 */
export const banPublisherNode = (
    publisherId: string,
    nodeId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/ban`, method: 'POST'
    },
      options);
    }
  


export const getBanPublisherNodeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof banPublisherNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof banPublisherNode>>, TError,{publisherId: string;nodeId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof banPublisherNode>>, {publisherId: string;nodeId: string}> = (props) => {
          const {publisherId,nodeId} = props ?? {};

          return  banPublisherNode(publisherId,nodeId,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type BanPublisherNodeMutationResult = NonNullable<Awaited<ReturnType<typeof banPublisherNode>>>
    
    export type BanPublisherNodeMutationError = ErrorResponse

    /**
 * @summary Ban a publisher's Node
 */
export const useBanPublisherNode = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof banPublisherNode>>, TError,{publisherId: string;nodeId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {

      const mutationOptions = getBanPublisherNodeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Retrieve permissions the user has for a given publisher
 */
export const getPermissionOnPublisherNodes = (
    publisherId: string,
    nodeId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetPermissionOnPublisherNodes200>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/permissions`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPermissionOnPublisherNodesQueryKey = (publisherId: string,
    nodeId: string,) => {
    return [`/publishers/${publisherId}/nodes/${nodeId}/permissions`] as const;
    }

    
export const getGetPermissionOnPublisherNodesQueryOptions = <TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError = ErrorResponse>(publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPermissionOnPublisherNodesQueryKey(publisherId,nodeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>> = ({ signal }) => getPermissionOnPublisherNodes(publisherId,nodeId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId && nodeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPermissionOnPublisherNodesQueryResult = NonNullable<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>>
export type GetPermissionOnPublisherNodesQueryError = ErrorResponse

/**
 * @summary Retrieve permissions the user has for a given publisher
 */
export const useGetPermissionOnPublisherNodes = <TData = Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError = ErrorResponse>(
 publisherId: string,
    nodeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisherNodes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPermissionOnPublisherNodesQueryOptions(publisherId,nodeId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
>>>>>>> 9eedfeb (Add url params.)
 * @summary Publish a new version of a node
 */
export const publishNodeVersion = (
    publisherId: string,
    nodeId: string,
    publishNodeVersionBody: PublishNodeVersionBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<PublishNodeVersion201>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/versions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: publishNodeVersionBody
    },
      options);
    }
  


<<<<<<< HEAD
export const getPublishNodeVersionMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};
=======
export const getPublishNodeVersionMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};
>>>>>>> 9eedfeb (Add url params.)

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof publishNodeVersion>>, {publisherId: string;nodeId: string;data: PublishNodeVersionBody}> = (props) => {
          const {publisherId,nodeId,data} = props ?? {};

          return  publishNodeVersion(publisherId,nodeId,data,requestOptions)
        }

        


<<<<<<< HEAD
  return  { mutationFn, ...mutationOptions }}

    export type PublishNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof publishNodeVersion>>>
    export type PublishNodeVersionMutationBody = PublishNodeVersionBody
    export type PublishNodeVersionMutationError = Error
=======
   return  { mutationFn, ...mutationOptions }}

    export type PublishNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof publishNodeVersion>>>
    export type PublishNodeVersionMutationBody = PublishNodeVersionBody
    export type PublishNodeVersionMutationError = ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

    /**
 * @summary Publish a new version of a node
 */
<<<<<<< HEAD
export const usePublishNodeVersion = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof publishNodeVersion>>,
        TError,
        {publisherId: string;nodeId: string;data: PublishNodeVersionBody},
        TContext
      > => {
=======
export const usePublishNodeVersion = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishNodeVersion>>, TError,{publisherId: string;nodeId: string;data: PublishNodeVersionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
>>>>>>> 9eedfeb (Add url params.)

      const mutationOptions = getPublishNodeVersionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Unpublish (delete) a specific version of a node
 */
export const deleteNodeVersion = (
    publisherId: string,
    nodeId: string,
    versionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/versions/${versionId}`, method: 'DELETE'
    },
      options);
    }
  


<<<<<<< HEAD
export const getDeleteNodeVersionMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};
=======
export const getDeleteNodeVersionMutationOptions = <TError = ErrorResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};
>>>>>>> 9eedfeb (Add url params.)

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNodeVersion>>, {publisherId: string;nodeId: string;versionId: string}> = (props) => {
          const {publisherId,nodeId,versionId} = props ?? {};

          return  deleteNodeVersion(publisherId,nodeId,versionId,requestOptions)
        }

        


<<<<<<< HEAD
  return  { mutationFn, ...mutationOptions }}

    export type DeleteNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNodeVersion>>>
    
    export type DeleteNodeVersionMutationError = Error
=======
   return  { mutationFn, ...mutationOptions }}

    export type DeleteNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNodeVersion>>>
    
    export type DeleteNodeVersionMutationError = ErrorResponse | Error
>>>>>>> 9eedfeb (Add url params.)

    /**
 * @summary Unpublish (delete) a specific version of a node
 */
<<<<<<< HEAD
export const useDeleteNodeVersion = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteNodeVersion>>,
        TError,
        {publisherId: string;nodeId: string;versionId: string},
        TContext
      > => {
=======
export const useDeleteNodeVersion = <TError = ErrorResponse | Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
>>>>>>> 9eedfeb (Add url params.)

      const mutationOptions = getDeleteNodeVersionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Update only the changelog and deprecated status of a specific version of a node.
 * @summary Update changelog and deprecation status of a node version
 */
export const updateNodeVersion = (
    publisherId: string,
    nodeId: string,
    versionId: string,
    nodeVersionUpdateRequest: NodeVersionUpdateRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<NodeVersion>(
      {url: `/publishers/${publisherId}/nodes/${nodeId}/versions/${versionId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: nodeVersionUpdateRequest
    },
      options);
    }
  


<<<<<<< HEAD
export const getUpdateNodeVersionMutationOptions = <TError = Error | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};
=======
export const getUpdateNodeVersionMutationOptions = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};
>>>>>>> 9eedfeb (Add url params.)

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateNodeVersion>>, {publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}> = (props) => {
          const {publisherId,nodeId,versionId,data} = props ?? {};

          return  updateNodeVersion(publisherId,nodeId,versionId,data,requestOptions)
        }

        


<<<<<<< HEAD
  return  { mutationFn, ...mutationOptions }}

    export type UpdateNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof updateNodeVersion>>>
    export type UpdateNodeVersionMutationBody = NodeVersionUpdateRequest
    export type UpdateNodeVersionMutationError = Error | void
=======
   return  { mutationFn, ...mutationOptions }}

    export type UpdateNodeVersionMutationResult = NonNullable<Awaited<ReturnType<typeof updateNodeVersion>>>
    export type UpdateNodeVersionMutationBody = NodeVersionUpdateRequest
    export type UpdateNodeVersionMutationError = ErrorResponse | void
>>>>>>> 9eedfeb (Add url params.)

    /**
 * @summary Update changelog and deprecation status of a node version
 */
<<<<<<< HEAD
export const useUpdateNodeVersion = <TError = Error | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateNodeVersion>>,
        TError,
        {publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest},
        TContext
      > => {
=======
export const useUpdateNodeVersion = <TError = ErrorResponse | void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNodeVersion>>, TError,{publisherId: string;nodeId: string;versionId: string;data: NodeVersionUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
>>>>>>> 9eedfeb (Add url params.)

      const mutationOptions = getUpdateNodeVersionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
<<<<<<< HEAD
=======
 * @summary Retrieve permissions the user has for a given publisher
 */
export const getPermissionOnPublisher = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetPermissionOnPublisher200>(
      {url: `/publishers/${publisherId}/permissions`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPermissionOnPublisherQueryKey = (publisherId: string,) => {
    return [`/publishers/${publisherId}/permissions`] as const;
    }

    
export const getGetPermissionOnPublisherQueryOptions = <TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError = ErrorResponse>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPermissionOnPublisherQueryKey(publisherId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPermissionOnPublisher>>> = ({ signal }) => getPermissionOnPublisher(publisherId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPermissionOnPublisherQueryResult = NonNullable<Awaited<ReturnType<typeof getPermissionOnPublisher>>>
export type GetPermissionOnPublisherQueryError = ErrorResponse

/**
 * @summary Retrieve permissions the user has for a given publisher
 */
export const useGetPermissionOnPublisher = <TData = Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError = ErrorResponse>(
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPermissionOnPublisher>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPermissionOnPublisherQueryOptions(publisherId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
>>>>>>> 9eedfeb (Add url params.)
 * @summary Retrieve all personal access tokens for a publisher
 */
export const listPersonalAccessTokens = (
    publisherId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PersonalAccessToken[]>(
      {url: `/publishers/${publisherId}/tokens`, method: 'GET', signal
    },
      options);
    }
  

export const getListPersonalAccessTokensQueryKey = (publisherId: string,) => {
    return [`/publishers/${publisherId}/tokens`] as const;
    }

    
<<<<<<< HEAD
export const getListPersonalAccessTokensQueryOptions = <TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = Error>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
=======
export const getListPersonalAccessTokensQueryOptions = <TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = ErrorResponse>(publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
>>>>>>> 9eedfeb (Add url params.)
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPersonalAccessTokensQueryKey(publisherId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPersonalAccessTokens>>> = ({ signal }) => listPersonalAccessTokens(publisherId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(publisherId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData> & { queryKey: QueryKey }
}

export type ListPersonalAccessTokensQueryResult = NonNullable<Awaited<ReturnType<typeof listPersonalAccessTokens>>>
<<<<<<< HEAD
export type ListPersonalAccessTokensQueryError = Error
=======
export type ListPersonalAccessTokensQueryError = ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

/**
 * @summary Retrieve all personal access tokens for a publisher
 */
<<<<<<< HEAD
export const useListPersonalAccessTokens = <TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = Error>(
=======
export const useListPersonalAccessTokens = <TData = Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError = ErrorResponse>(
>>>>>>> 9eedfeb (Add url params.)
 publisherId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPersonalAccessTokens>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListPersonalAccessTokensQueryOptions(publisherId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new personal access token
 */
export const createPersonalAccessToken = (
    publisherId: string,
    personalAccessToken: PersonalAccessToken,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreatePersonalAccessToken201>(
      {url: `/publishers/${publisherId}/tokens`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: personalAccessToken
    },
      options);
    }
  


<<<<<<< HEAD
export const getCreatePersonalAccessTokenMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};
=======
export const getCreatePersonalAccessTokenMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};
>>>>>>> 9eedfeb (Add url params.)

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPersonalAccessToken>>, {publisherId: string;data: PersonalAccessToken}> = (props) => {
          const {publisherId,data} = props ?? {};

          return  createPersonalAccessToken(publisherId,data,requestOptions)
        }

        


<<<<<<< HEAD
  return  { mutationFn, ...mutationOptions }}

    export type CreatePersonalAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof createPersonalAccessToken>>>
    export type CreatePersonalAccessTokenMutationBody = PersonalAccessToken
    export type CreatePersonalAccessTokenMutationError = Error
=======
   return  { mutationFn, ...mutationOptions }}

    export type CreatePersonalAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof createPersonalAccessToken>>>
    export type CreatePersonalAccessTokenMutationBody = PersonalAccessToken
    export type CreatePersonalAccessTokenMutationError = ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

    /**
 * @summary Create a new personal access token
 */
<<<<<<< HEAD
export const useCreatePersonalAccessToken = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createPersonalAccessToken>>,
        TError,
        {publisherId: string;data: PersonalAccessToken},
        TContext
      > => {
=======
export const useCreatePersonalAccessToken = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPersonalAccessToken>>, TError,{publisherId: string;data: PersonalAccessToken}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
>>>>>>> 9eedfeb (Add url params.)

      const mutationOptions = getCreatePersonalAccessTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a specific personal access token
 */
export const deletePersonalAccessToken = (
    publisherId: string,
    tokenId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/publishers/${publisherId}/tokens/${tokenId}`, method: 'DELETE'
    },
      options);
    }
  


<<<<<<< HEAD
export const getDeletePersonalAccessTokenMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};
=======
export const getDeletePersonalAccessTokenMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};
>>>>>>> 9eedfeb (Add url params.)

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePersonalAccessToken>>, {publisherId: string;tokenId: string}> = (props) => {
          const {publisherId,tokenId} = props ?? {};

          return  deletePersonalAccessToken(publisherId,tokenId,requestOptions)
        }

        


<<<<<<< HEAD
  return  { mutationFn, ...mutationOptions }}

    export type DeletePersonalAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof deletePersonalAccessToken>>>
    
    export type DeletePersonalAccessTokenMutationError = Error
=======
   return  { mutationFn, ...mutationOptions }}

    export type DeletePersonalAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof deletePersonalAccessToken>>>
    
    export type DeletePersonalAccessTokenMutationError = ErrorResponse
>>>>>>> 9eedfeb (Add url params.)

    /**
 * @summary Delete a specific personal access token
 */
<<<<<<< HEAD
export const useDeletePersonalAccessToken = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deletePersonalAccessToken>>,
        TError,
        {publisherId: string;tokenId: string},
        TContext
      > => {
=======
export const useDeletePersonalAccessToken = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePersonalAccessToken>>, TError,{publisherId: string;tokenId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
>>>>>>> 9eedfeb (Add url params.)

      const mutationOptions = getDeletePersonalAccessTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
<<<<<<< HEAD
=======
 * Pull all pending node versions and conduct security scans.
 * @summary Security Scan
 */
export const securityScan = (
    params?: SecurityScanParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/security-scan`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getSecurityScanQueryKey = (params?: SecurityScanParams,) => {
    return [`/security-scan`, ...(params ? [params]: [])] as const;
    }

    
export const getSecurityScanQueryOptions = <TData = Awaited<ReturnType<typeof securityScan>>, TError = ErrorResponse>(params?: SecurityScanParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSecurityScanQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof securityScan>>> = ({ signal }) => securityScan(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData> & { queryKey: QueryKey }
}

export type SecurityScanQueryResult = NonNullable<Awaited<ReturnType<typeof securityScan>>>
export type SecurityScanQueryError = ErrorResponse

/**
 * @summary Security Scan
 */
export const useSecurityScan = <TData = Awaited<ReturnType<typeof securityScan>>, TError = ErrorResponse>(
 params?: SecurityScanParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof securityScan>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSecurityScanQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
>>>>>>> 9eedfeb (Add url params.)
 * @summary Receive artifacts (output files) from the ComfyUI GitHub Action
 */
export const postUploadArtifact = (
    postUploadArtifactBody: PostUploadArtifactBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<PostUploadArtifact200>(
      {url: `/upload-artifact`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postUploadArtifactBody
    },
      options);
    }
  


export const getPostUploadArtifactMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUploadArtifact>>, TError,{data: PostUploadArtifactBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postUploadArtifact>>, TError,{data: PostUploadArtifactBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUploadArtifact>>, {data: PostUploadArtifactBody}> = (props) => {
          const {data} = props ?? {};

          return  postUploadArtifact(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostUploadArtifactMutationResult = NonNullable<Awaited<ReturnType<typeof postUploadArtifact>>>
    export type PostUploadArtifactMutationBody = PostUploadArtifactBody
    export type PostUploadArtifactMutationError = void

    /**
 * @summary Receive artifacts (output files) from the ComfyUI GitHub Action
 */
export const usePostUploadArtifact = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUploadArtifact>>, TError,{data: PostUploadArtifactBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof postUploadArtifact>>,
        TError,
        {data: PostUploadArtifactBody},
        TContext
      > => {

      const mutationOptions = getPostUploadArtifactMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get information about the calling user.
 */
export const getUser = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<User>(
      {url: `/users`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserQueryKey = () => {
    return [`/users`] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = void

/**
 * @summary Get information about the calling user.
 */
export const useGetUser = <TData = Awaited<ReturnType<typeof getUser>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Retrieve all publishers for a given user
<<<<<<< HEAD
 */
export const listPublishersForUser = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Publisher[]>(
      {url: `/users/publishers/`, method: 'GET', signal
    },
      options);
    }
  

export const getListPublishersForUserQueryKey = () => {
    return [`/users/publishers/`] as const;
    }

    
export const getListPublishersForUserQueryOptions = <TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPublishersForUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPublishersForUser>>> = ({ signal }) => listPublishersForUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData> & { queryKey: QueryKey }
}

export type ListPublishersForUserQueryResult = NonNullable<Awaited<ReturnType<typeof listPublishersForUser>>>
export type ListPublishersForUserQueryError = void

/**
 * @summary Retrieve all publishers for a given user
 */
export const useListPublishersForUser = <TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListPublishersForUserQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Stop sessions that have no active usage.
=======
>>>>>>> 9eedfeb (Add url params.)
 */
export const listPublishersForUser = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Publisher[]>(
      {url: `/users/publishers/`, method: 'GET', signal
    },
      options);
    }
  

export const getListPublishersForUserQueryKey = () => {
    return [`/users/publishers/`] as const;
    }

<<<<<<< HEAD
export const getStopExpiredSessionsMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stopExpiredSessions>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof stopExpiredSessions>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};
=======
    
export const getListPublishersForUserQueryOptions = <TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPublishersForUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPublishersForUser>>> = ({ signal }) => listPublishersForUser(requestOptions, signal);
>>>>>>> 9eedfeb (Add url params.)

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData> & { queryKey: QueryKey }
}

export type ListPublishersForUserQueryResult = NonNullable<Awaited<ReturnType<typeof listPublishersForUser>>>
export type ListPublishersForUserQueryError = ErrorResponse

<<<<<<< HEAD
        


  return  { mutationFn, ...mutationOptions }}

    export type StopExpiredSessionsMutationResult = NonNullable<Awaited<ReturnType<typeof stopExpiredSessions>>>
    
    export type StopExpiredSessionsMutationError = void

    /**
 * @summary Stop sessions that have no active usage.
 */
export const useStopExpiredSessions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof stopExpiredSessions>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof stopExpiredSessions>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getStopExpiredSessionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
=======
>>>>>>> 9eedfeb (Add url params.)
/**
 * @summary Retrieve all publishers for a given user
 */
export const useListPublishersForUser = <TData = Awaited<ReturnType<typeof listPublishersForUser>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPublishersForUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListPublishersForUserQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List all node versions given some filters.
 */
export const listAllNodeVersions = (
    params?: ListAllNodeVersionsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ListAllNodeVersions200>(
      {url: `/versions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListAllNodeVersionsQueryKey = (params?: ListAllNodeVersionsParams,) => {
    return [`/versions`, ...(params ? [params]: [])] as const;
    }

    
export const getListAllNodeVersionsQueryOptions = <TData = Awaited<ReturnType<typeof listAllNodeVersions>>, TError = ErrorResponse>(params?: ListAllNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAllNodeVersionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAllNodeVersions>>> = ({ signal }) => listAllNodeVersions(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData> & { queryKey: QueryKey }
}

export type ListAllNodeVersionsQueryResult = NonNullable<Awaited<ReturnType<typeof listAllNodeVersions>>>
export type ListAllNodeVersionsQueryError = ErrorResponse

/**
 * @summary List all node versions given some filters.
 */
export const useListAllNodeVersions = <TData = Awaited<ReturnType<typeof listAllNodeVersions>>, TError = ErrorResponse>(
 params?: ListAllNodeVersionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAllNodeVersions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListAllNodeVersionsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




<<<<<<< HEAD
/**
 * @summary Create a new session for a user. If an existing session is active (not deleted), it will be returned.
 */
export const createSession = (
    createSessionBody: CreateSessionBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Session>(
      {url: `/users/sessions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSessionBody
    },
      options);
    }
  


export const getCreateSessionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: CreateSessionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: CreateSessionBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSession>>, {data: CreateSessionBody}> = (props) => {
          const {data} = props ?? {};

          return  createSession(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof createSession>>>
    export type CreateSessionMutationBody = CreateSessionBody
    export type CreateSessionMutationError = void

    /**
 * @summary Create a new session for a user. If an existing session is active (not deleted), it will be returned.
 */
export const useCreateSession = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: CreateSessionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createSession>>,
        TError,
        {data: CreateSessionBody},
        TContext
      > => {

      const mutationOptions = getCreateSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a specific session by its ID.
 */
export const getSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Session>(
      {url: `/users/sessions/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSessionQueryKey = (sessionId: string,) => {
    return [`/users/sessions/${sessionId}`] as const;
    }

    
export const getGetSessionQueryOptions = <TData = Awaited<ReturnType<typeof getSession>>, TError = void>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionQueryError = void

/**
 * @summary Get a specific session by its ID.
 */
export const useGetSession = <TData = Awaited<ReturnType<typeof getSession>>, TError = void>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSessionQueryOptions(sessionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update a session by its ID.
 */
export const updateSession = (
    sessionId: string,
    updateSessionBody: UpdateSessionBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Session>(
      {url: `/users/sessions/${sessionId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateSessionBody
    },
      options);
    }
  


export const getUpdateSessionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string;data: UpdateSessionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string;data: UpdateSessionBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSession>>, {sessionId: string;data: UpdateSessionBody}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateSession(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof updateSession>>>
    export type UpdateSessionMutationBody = UpdateSessionBody
    export type UpdateSessionMutationError = void

    /**
 * @summary Update a session by its ID.
 */
export const useUpdateSession = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string;data: UpdateSessionBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateSession>>,
        TError,
        {sessionId: string;data: UpdateSessionBody},
        TContext
      > => {

      const mutationOptions = getUpdateSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Validates the provided access token and returns a session ID if valid.
 * @summary Validate an access token
 */
export const postValidateToken = (
    postValidateTokenBody: PostValidateTokenBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Session>(
      {url: `/validateToken`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postValidateTokenBody
    },
      options);
    }
  


export const getPostValidateTokenMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postValidateToken>>, TError,{data: PostValidateTokenBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postValidateToken>>, TError,{data: PostValidateTokenBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postValidateToken>>, {data: PostValidateTokenBody}> = (props) => {
          const {data} = props ?? {};

          return  postValidateToken(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostValidateTokenMutationResult = NonNullable<Awaited<ReturnType<typeof postValidateToken>>>
    export type PostValidateTokenMutationBody = PostValidateTokenBody
    export type PostValidateTokenMutationError = void

    /**
 * @summary Validate an access token
 */
export const usePostValidateToken = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postValidateToken>>, TError,{data: PostValidateTokenBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof postValidateToken>>,
        TError,
        {data: PostValidateTokenBody},
        TContext
      > => {

      const mutationOptions = getPostValidateTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all workflows
 */
export const getUserWorkflows = (
    params?: GetUserWorkflowsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetUserWorkflows200>(
      {url: `/workflows`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetUserWorkflowsQueryKey = (params?: GetUserWorkflowsParams,) => {
    return [`/workflows`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserWorkflowsQueryOptions = <TData = Awaited<ReturnType<typeof getUserWorkflows>>, TError = unknown>(params?: GetUserWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserWorkflows>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserWorkflowsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserWorkflows>>> = ({ signal }) => getUserWorkflows(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserWorkflows>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserWorkflowsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserWorkflows>>>
export type GetUserWorkflowsQueryError = unknown

/**
 * @summary Get all workflows
 */
export const useGetUserWorkflows = <TData = Awaited<ReturnType<typeof getUserWorkflows>>, TError = unknown>(
 params?: GetUserWorkflowsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserWorkflows>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserWorkflowsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new workflow
 */
export const createWorkflow = (
    createWorkflowBody: CreateWorkflowBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Workflow>(
      {url: `/workflows`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createWorkflowBody
    },
      options);
    }
  


export const getCreateWorkflowMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkflow>>, TError,{data: CreateWorkflowBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createWorkflow>>, TError,{data: CreateWorkflowBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createWorkflow>>, {data: CreateWorkflowBody}> = (props) => {
          const {data} = props ?? {};

          return  createWorkflow(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof createWorkflow>>>
    export type CreateWorkflowMutationBody = CreateWorkflowBody
    export type CreateWorkflowMutationError = void

    /**
 * @summary Create a new workflow
 */
export const useCreateWorkflow = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkflow>>, TError,{data: CreateWorkflowBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createWorkflow>>,
        TError,
        {data: CreateWorkflowBody},
        TContext
      > => {

      const mutationOptions = getCreateWorkflowMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a workflow
 */
export const deleteWorkflow = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/workflows/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteWorkflowMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflow>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflow>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteWorkflow>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteWorkflow(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof deleteWorkflow>>>
    
    export type DeleteWorkflowMutationError = void

    /**
 * @summary Delete a workflow
 */
export const useDeleteWorkflow = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWorkflow>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteWorkflow>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteWorkflowMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a workflow
 */
export const getWorkflow = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetWorkflow200>(
      {url: `/workflows/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWorkflowQueryKey = (id: string,) => {
    return [`/workflows/${id}`] as const;
    }

    
export const getGetWorkflowQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflow>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflow>>> = ({ signal }) => getWorkflow(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWorkflowQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflow>>>
export type GetWorkflowQueryError = void

/**
 * @summary Get a workflow
 */
export const useGetWorkflow = <TData = Awaited<ReturnType<typeof getWorkflow>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflow>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWorkflowQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update an existing workflow
 */
export const updateWorkflow = (
    id: string,
    workflow: Workflow,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Workflow>(
      {url: `/workflows/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: workflow
    },
      options);
    }
  


export const getUpdateWorkflowMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkflow>>, TError,{id: string;data: Workflow}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateWorkflow>>, TError,{id: string;data: Workflow}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateWorkflow>>, {id: string;data: Workflow}> = (props) => {
          const {id,data} = props ?? {};

          return  updateWorkflow(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateWorkflowMutationResult = NonNullable<Awaited<ReturnType<typeof updateWorkflow>>>
    export type UpdateWorkflowMutationBody = Workflow
    export type UpdateWorkflowMutationError = void

    /**
 * @summary Update an existing workflow
 */
export const useUpdateWorkflow = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkflow>>, TError,{id: string;data: Workflow}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateWorkflow>>,
        TError,
        {id: string;data: Workflow},
        TContext
      > => {

      const mutationOptions = getUpdateWorkflowMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Create a new job for a specific workflow
 */
export const createWorkflowJob = (
    workflowId: string,
    createWorkflowJobBody: CreateWorkflowJobBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<WorkflowJob>(
      {url: `/workflows/${workflowId}/jobs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createWorkflowJobBody
    },
      options);
    }
  


export const getCreateWorkflowJobMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkflowJob>>, TError,{workflowId: string;data: CreateWorkflowJobBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createWorkflowJob>>, TError,{workflowId: string;data: CreateWorkflowJobBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createWorkflowJob>>, {workflowId: string;data: CreateWorkflowJobBody}> = (props) => {
          const {workflowId,data} = props ?? {};

          return  createWorkflowJob(workflowId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateWorkflowJobMutationResult = NonNullable<Awaited<ReturnType<typeof createWorkflowJob>>>
    export type CreateWorkflowJobMutationBody = CreateWorkflowJobBody
    export type CreateWorkflowJobMutationError = void

    /**
 * @summary Create a new job for a specific workflow
 */
export const useCreateWorkflowJob = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkflowJob>>, TError,{workflowId: string;data: CreateWorkflowJobBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createWorkflowJob>>,
        TError,
        {workflowId: string;data: CreateWorkflowJobBody},
        TContext
      > => {

      const mutationOptions = getCreateWorkflowJobMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a job by ID for a specific workflow
 */
export const getWorkflowJob = (
    workflowId: string,
    jobId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkflowJob>(
      {url: `/workflows/${workflowId}/jobs/${jobId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWorkflowJobQueryKey = (workflowId: string,
    jobId: string,) => {
    return [`/workflows/${workflowId}/jobs/${jobId}`] as const;
    }

    
export const getGetWorkflowJobQueryOptions = <TData = Awaited<ReturnType<typeof getWorkflowJob>>, TError = void>(workflowId: string,
    jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowJob>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkflowJobQueryKey(workflowId,jobId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkflowJob>>> = ({ signal }) => getWorkflowJob(workflowId,jobId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(workflowId && jobId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkflowJob>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWorkflowJobQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkflowJob>>>
export type GetWorkflowJobQueryError = void

/**
 * @summary Get a job by ID for a specific workflow
 */
export const useGetWorkflowJob = <TData = Awaited<ReturnType<typeof getWorkflowJob>>, TError = void>(
 workflowId: string,
    jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkflowJob>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWorkflowJobQueryOptions(workflowId,jobId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update a job's status and output URLs for a specific workflow
 */
export const updateWorkflowJob = (
    workflowId: string,
    jobId: string,
    updateWorkflowJobBody: UpdateWorkflowJobBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<WorkflowJob>(
      {url: `/workflows/${workflowId}/jobs/${jobId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateWorkflowJobBody
    },
      options);
    }
  


export const getUpdateWorkflowJobMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkflowJob>>, TError,{workflowId: string;jobId: string;data: UpdateWorkflowJobBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateWorkflowJob>>, TError,{workflowId: string;jobId: string;data: UpdateWorkflowJobBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateWorkflowJob>>, {workflowId: string;jobId: string;data: UpdateWorkflowJobBody}> = (props) => {
          const {workflowId,jobId,data} = props ?? {};

          return  updateWorkflowJob(workflowId,jobId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateWorkflowJobMutationResult = NonNullable<Awaited<ReturnType<typeof updateWorkflowJob>>>
    export type UpdateWorkflowJobMutationBody = UpdateWorkflowJobBody
    export type UpdateWorkflowJobMutationError = ErrorResponse

    /**
 * @summary Update a job's status and output URLs for a specific workflow
 */
export const useUpdateWorkflowJob = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkflowJob>>, TError,{workflowId: string;jobId: string;data: UpdateWorkflowJobBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateWorkflowJob>>,
        TError,
        {workflowId: string;jobId: string;data: UpdateWorkflowJobBody},
        TContext
      > => {

      const mutationOptions = getUpdateWorkflowJobMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Cancel a specific job for a workflow
 */
export const cancelWorkflowJob = (
    workflowId: string,
    jobId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CancelWorkflowJob200>(
      {url: `/workflows/${workflowId}/jobs/${jobId}/cancel`, method: 'POST'
    },
      options);
    }
  


export const getCancelWorkflowJobMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelWorkflowJob>>, TError,{workflowId: string;jobId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof cancelWorkflowJob>>, TError,{workflowId: string;jobId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelWorkflowJob>>, {workflowId: string;jobId: string}> = (props) => {
          const {workflowId,jobId} = props ?? {};

          return  cancelWorkflowJob(workflowId,jobId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelWorkflowJobMutationResult = NonNullable<Awaited<ReturnType<typeof cancelWorkflowJob>>>
    
    export type CancelWorkflowJobMutationError = void

    /**
 * @summary Cancel a specific job for a workflow
 */
export const useCancelWorkflowJob = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelWorkflowJob>>, TError,{workflowId: string;jobId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof cancelWorkflowJob>>,
        TError,
        {workflowId: string;jobId: string},
        TContext
      > => {

      const mutationOptions = getCancelWorkflowJobMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all workspaces for the user
 */
export const getWorkspaces = (
    params?: GetWorkspacesParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetWorkspaces200>(
      {url: `/workspace`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetWorkspacesQueryKey = (params?: GetWorkspacesParams,) => {
    return [`/workspace`, ...(params ? [params]: [])] as const;
    }

    
export const getGetWorkspacesQueryOptions = <TData = Awaited<ReturnType<typeof getWorkspaces>>, TError = void>(params?: GetWorkspacesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkspaces>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkspacesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkspaces>>> = ({ signal }) => getWorkspaces(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkspaces>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWorkspacesQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkspaces>>>
export type GetWorkspacesQueryError = void

/**
 * @summary Get all workspaces for the user
 */
export const useGetWorkspaces = <TData = Awaited<ReturnType<typeof getWorkspaces>>, TError = void>(
 params?: GetWorkspacesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkspaces>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWorkspacesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new workspace
 */
export const createWorkspace = (
    createWorkspaceBody: CreateWorkspaceBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateWorkspace201>(
      {url: `/workspace`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createWorkspaceBody
    },
      options);
    }
  


export const getCreateWorkspaceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkspace>>, TError,{data: CreateWorkspaceBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createWorkspace>>, TError,{data: CreateWorkspaceBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createWorkspace>>, {data: CreateWorkspaceBody}> = (props) => {
          const {data} = props ?? {};

          return  createWorkspace(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateWorkspaceMutationResult = NonNullable<Awaited<ReturnType<typeof createWorkspace>>>
    export type CreateWorkspaceMutationBody = CreateWorkspaceBody
    export type CreateWorkspaceMutationError = void

    /**
 * @summary Create a new workspace
 */
export const useCreateWorkspace = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkspace>>, TError,{data: CreateWorkspaceBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createWorkspace>>,
        TError,
        {data: CreateWorkspaceBody},
        TContext
      > => {

      const mutationOptions = getCreateWorkspaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Create the default workspace. It retrieves the default workspace if it already exists.
 */
export const createDefaultWorkspace = (
    
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateDefaultWorkspace201>(
      {url: `/workspace/default`, method: 'POST'
    },
      options);
    }
  


export const getCreateDefaultWorkspaceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDefaultWorkspace>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createDefaultWorkspace>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDefaultWorkspace>>, void> = () => {
          

          return  createDefaultWorkspace(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDefaultWorkspaceMutationResult = NonNullable<Awaited<ReturnType<typeof createDefaultWorkspace>>>
    
    export type CreateDefaultWorkspaceMutationError = void

    /**
 * @summary Create the default workspace. It retrieves the default workspace if it already exists.
 */
export const useCreateDefaultWorkspace = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDefaultWorkspace>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createDefaultWorkspace>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateDefaultWorkspaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a workspace by ID
 */
export const getWorkspace = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetWorkspace200>(
      {url: `/workspace/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWorkspaceQueryKey = (id: string,) => {
    return [`/workspace/${id}`] as const;
    }

    
export const getGetWorkspaceQueryOptions = <TData = Awaited<ReturnType<typeof getWorkspace>>, TError = void>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkspace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkspaceQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkspace>>> = ({ signal }) => getWorkspace(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkspace>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWorkspaceQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkspace>>>
export type GetWorkspaceQueryError = void

/**
 * @summary Get a workspace by ID
 */
export const useGetWorkspace = <TData = Awaited<ReturnType<typeof getWorkspace>>, TError = void>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkspace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWorkspaceQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update the workspace with the workflow content
 */
export const updateWorkspace = (
    id: string,
    updateWorkspaceBody: UpdateWorkspaceBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateWorkspace200>(
      {url: `/workspace/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateWorkspaceBody
    },
      options);
    }
  


export const getUpdateWorkspaceMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkspace>>, TError,{id: string;data: UpdateWorkspaceBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateWorkspace>>, TError,{id: string;data: UpdateWorkspaceBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateWorkspace>>, {id: string;data: UpdateWorkspaceBody}> = (props) => {
          const {id,data} = props ?? {};

          return  updateWorkspace(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateWorkspaceMutationResult = NonNullable<Awaited<ReturnType<typeof updateWorkspace>>>
    export type UpdateWorkspaceMutationBody = UpdateWorkspaceBody
    export type UpdateWorkspaceMutationError = void

    /**
 * @summary Update the workspace with the workflow content
 */
export const useUpdateWorkspace = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWorkspace>>, TError,{id: string;data: UpdateWorkspaceBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateWorkspace>>,
        TError,
        {id: string;data: UpdateWorkspaceBody},
        TContext
      > => {

      const mutationOptions = getUpdateWorkspaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all snapshots for the workspace
 */
export const getWorkspaceSnapshots = (
    workspaceId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetWorkspaceSnapshots200>(
      {url: `/workspace/${workspaceId}/snapshot`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWorkspaceSnapshotsQueryKey = (workspaceId: string,) => {
    return [`/workspace/${workspaceId}/snapshot`] as const;
    }

    
export const getGetWorkspaceSnapshotsQueryOptions = <TData = Awaited<ReturnType<typeof getWorkspaceSnapshots>>, TError = void>(workspaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkspaceSnapshots>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWorkspaceSnapshotsQueryKey(workspaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWorkspaceSnapshots>>> = ({ signal }) => getWorkspaceSnapshots(workspaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(workspaceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWorkspaceSnapshots>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWorkspaceSnapshotsQueryResult = NonNullable<Awaited<ReturnType<typeof getWorkspaceSnapshots>>>
export type GetWorkspaceSnapshotsQueryError = void

/**
 * @summary Get all snapshots for the workspace
 */
export const useGetWorkspaceSnapshots = <TData = Awaited<ReturnType<typeof getWorkspaceSnapshots>>, TError = void>(
 workspaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWorkspaceSnapshots>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWorkspaceSnapshotsQueryOptions(workspaceId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a snapshot of the current workspace
 */
export const createWorkspaceSnapshot = (
    workspaceId: string,
    createWorkspaceSnapshotBody: CreateWorkspaceSnapshotBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateWorkspaceSnapshot201>(
      {url: `/workspace/${workspaceId}/snapshot/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createWorkspaceSnapshotBody
    },
      options);
    }
  


export const getCreateWorkspaceSnapshotMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkspaceSnapshot>>, TError,{workspaceId: string;data: CreateWorkspaceSnapshotBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createWorkspaceSnapshot>>, TError,{workspaceId: string;data: CreateWorkspaceSnapshotBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createWorkspaceSnapshot>>, {workspaceId: string;data: CreateWorkspaceSnapshotBody}> = (props) => {
          const {workspaceId,data} = props ?? {};

          return  createWorkspaceSnapshot(workspaceId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateWorkspaceSnapshotMutationResult = NonNullable<Awaited<ReturnType<typeof createWorkspaceSnapshot>>>
    export type CreateWorkspaceSnapshotMutationBody = CreateWorkspaceSnapshotBody
    export type CreateWorkspaceSnapshotMutationError = void

    /**
 * @summary Create a snapshot of the current workspace
 */
export const useCreateWorkspaceSnapshot = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWorkspaceSnapshot>>, TError,{workspaceId: string;data: CreateWorkspaceSnapshotBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createWorkspaceSnapshot>>,
        TError,
        {workspaceId: string;data: CreateWorkspaceSnapshotBody},
        TContext
      > => {

      const mutationOptions = getCreateWorkspaceSnapshotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Load a workspace snapshot
 */
export const loadWorkspaceSnapshot = (
    workspaceId: string,
    snapshotId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<LoadWorkspaceSnapshot200>(
      {url: `/workspace/${workspaceId}/snapshot/${snapshotId}/load/`, method: 'POST'
    },
      options);
    }
  


export const getLoadWorkspaceSnapshotMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loadWorkspaceSnapshot>>, TError,{workspaceId: string;snapshotId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof loadWorkspaceSnapshot>>, TError,{workspaceId: string;snapshotId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loadWorkspaceSnapshot>>, {workspaceId: string;snapshotId: string}> = (props) => {
          const {workspaceId,snapshotId} = props ?? {};

          return  loadWorkspaceSnapshot(workspaceId,snapshotId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoadWorkspaceSnapshotMutationResult = NonNullable<Awaited<ReturnType<typeof loadWorkspaceSnapshot>>>
    
    export type LoadWorkspaceSnapshotMutationError = void

    /**
 * @summary Load a workspace snapshot
 */
export const useLoadWorkspaceSnapshot = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loadWorkspaceSnapshot>>, TError,{workspaceId: string;snapshotId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof loadWorkspaceSnapshot>>,
        TError,
        {workspaceId: string;snapshotId: string},
        TContext
      > => {

      const mutationOptions = getLoadWorkspaceSnapshotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
=======
>>>>>>> 9eedfeb (Add url params.)
